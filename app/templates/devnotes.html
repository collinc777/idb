{% extends "base.html" %}
{% block content %}
<div class="row text-center">
	<h1>Developer Notes</h1>
	<br />
</div>
<div class="container">
	<h2>Use Cases</h2>
	<p>This website offers Game of Thrones fans the ability to look up detailed information on their favorite books, characters, houses, and more. We have set up an easy to use comprehensive UI that will let end users to puruse the data in a user friendly manner. We utilize two separate APIs to ensure the completeness of our dataset; unfortunately this does create a data overlap that needs to be addressed on the back-end. Our back-end tools format and groups the data so that the front end can access all of the DB information in a simple to read format. Our front-end allows the end user to access the DB and cross-reference their own encyclopedic knowledge. Our front end includes pages that display information by book, house, and characters. We can add pages for any additional models we build. Each model instance has its own static page which displays all of the pertinant data including links to related models. Beaches each page has links to related pages our front-end allows for a continuous user experience. End users can traverse the pages in a mapped pattern due to the intricate connection between the pages on character id and house id. Users will find this experience very similar to websites like IMDB.</p>
	<h2>RESTful API</h2>
	<p>Two APIs are scraped to create the tables and relations. An API of Ice and Fire, and GOT API, these APIs have detailed information on each character, house, book, and location. This allows for the basic models for Character, House, and Book; the relationships between these datasets allow us to construct more complex models like alliances between houses. The GOT API also has models for events, continents, cultures, etc. These models could be used to extend our functionality. We can create models for major events like wars which travers many characters, houses, regions, books, etc.</p>
	<h2>Models</h2>
	<h3>Books Model:</h3>
	<p>Books contain attributes ID, number of pages, ISBN number, title, publisher, country of origin, list of pov characters, author, media type, release date, list of all characters.
      This model allows our website to give the end user all pertinent data regarding any given book. The functionality of our books model can be extended by adding foreign keys for new and complex models. Each book covers a massive amount of characters, places, and events that can be linked to the book using our other models. Currently the basic behavior of linking this model to all of the characters that appear in the book allows our end users to examine each character in detail. We can even differentiate main characters from supporting roles due to the separation of POV and all character sets. Each row in the books table shares several attributes including author and media type, however the unique constraints on ID, name, and ISBN allow us to link complex models back to the book model and sort in a number of ways.</p>
      <h3>Characters Model:</h3>
      <p>Characters contain attributes ID, house, culture, title(s), spouse, died, aliases, date of death, name, born, gender, father, allegiances, pov books, played by, books, tv series, mother, male
      There are some redundant attributes due to the combination of two separate APIs.  This explains the presence of both male and gender attributes in the same mode. Even so, this model allows us to search for characters by blood line, allegiance, books appeared in, or actor. Furthermore it links to the Books, Houses, and Alliances models so that users can switch back and forth between examining specific character data and more general groups of data. Characters are the simplest of our models. While many models contain lists of characters, the character model itself links to only one house and/or alliance. Each character is linked in some way to the rest of the DB because by definition they must be a member of a house and have appeared in one or more books. Additionally we can create complex models to model the relationship between characters like a family or employer model. the Character model can be easily extended to add foreign keys to link to models like major events or covert plots.</p>
      <h3>Houses Model:</h3>
      <p> Houses contain attributes ID, current lord, founder, heir, cadet branches, founded, died out, titles, coat of arms, words, seats, overlord, name, sworn members, region, and ancestral weapons. 
      The House Model creates groups of characters and assigns them group attributes like lord they owe allegiance to, or family motto ("words"). Many characters can be sworn to a house, and an entire house can be sworn to another house (i.e. Karstark -> Stark). This allows us to create  complex models like an Alliance Model that groups houses/characters into trees of allegiance. In addition, we can define relationships between houses such as rivalries/wars, debts, etc through  models like events that use house id as foreign keys. This would allow users to visualize the complex relationships between the houses in Game of Thrones. Houses also have attributes for coat of arms and words which are displayed on each houses page as static media. This functionality can be extended to include media linked to castles("seats") or ancestral weapons. </p>
	<h2>Tools</h2>
	<h3>Front-End Tools</h3>
	<p></p>
	<h3>Back-End Tools</h3>
	<p>Our application uses the standard requests and JSON library to query the APIs we use to populate our models. After we have received the JSON data dumps we use trim scripts to format the data into the desired input format. Firstly we determine which entity we are dealing with which defines which attributes are required. Then we break the data into its required fields which allows us to populate our models fully while throwing out unneeded data. The complexity comes in when you take into account the differences between the two API data sets. For example in GOT API a name may be listed as Eddard Stark while on the Song of Ice and FIre API the name would be listed as Eddard Stark, Lord of Winterfel. In order to resolve this issue we search for names as sub strings so Eddard Stark would be returned because it is a sub string of both listed names. Unfortunately this creates a source of error that can only be controlled by creating a very specific script/method to handle each data set. </p>
	<h3>Embedding-Media Tools:</h3>
	<p></p>
	<h2>Hosting</h2>
	<p>For hosting we decided to use AWS. AWS’s Elastic Beanstalk became the perfect hosting platform for our project. Firstly, it supported the flask framework. Elastic Beanstalk (EB for short) does not support everything and that’s why it is key that it supports flask.  Elastic beanstalk not only acts as a host environment, but it adds some nice extra functionality on top of it, such as giving itself a URL right off the start. The next reason we chose to use it is that the applications deployment process across machines can easily be replicated due to the aws elastic beanstalk cli. Beanstalk also reduces the management complexity for our application by handling capacity provisioning, load balancing, scaling. It also offers application health monitoring.  Beanstalk also has a nice versioning system so that we can easily roll back our application upon failed deployment, or because of deploying bad code. </p>
	<p>The step by step setup of the project goes as follows. (Prerequisite: you must have Python3.4, pip, virtualenv, and the awsebcli installed to perform the next steps. You must also have the idb repo locally)</p>
	<h4>Create a virtualenv</h4>
	<p style="margin-left: 40px">    virtualenv ~/eb-virt</p>
	<h4>Activate virtualenv</h4>
	<p style="margin-left: 40px">    source ~/eb-virt/bin/activate</p>
	<h4>Navigate to IDB and install requirment</h4>
	<p style="margin-left: 40px">    pip install -r idb/requirment.txt</p>
	<h4>Initialize eb clie repo</h4>
	<p style="margin-left: 40px">    eb init -p python2.7 flask tutorial</p>
	<h4>Create an eb environment to deploy application into</h4>
	<p style="margin-left: 40px">    eb create flask-env</p>
	<p>To make deployment to beanstalk even simpler and to make development more streamlined, we used Pycharm’s built in Elastic Beanstalk plugin to handle deployment as a run configuration. This plugin syncs with your aws account. Allows you to select and environment to deploy to and streamlines deployment whenever the user is ready to deploy by selecting the Elastic Beanstalk run configuration. </p>
</div>
{% endblock %}

<!--Write an initial technical report
It must be at least 2500 words.
The report must be embedded in the website.
Document the use cases, RESTful API, models, tools, and hosting well.
The audience comprises other software developers, as opposed to users.
Format the report clearly, attractively, and consistently, using good sections, multiple pages, good headers, figures, and grammar. -->
