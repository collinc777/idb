{% extends "base.html" %}
{% block content %}
<div class="row text-center">
	<h1>Developer Notes</h1>
	<br />
</div>
<div class="container">
	<h2>Use Cases</h2>
	<p>This website offers Game of Thrones fans the ability to look up detailed information on their favorite books, characters, houses, and more. We have set up an easy to use comprehensive UI that will let end users to peruse the data in a user friendly manner. Our pages map to our DB models with many foreign key relationships that link to other pages. A user can skip from alliance, to house, to character, and back with ease. We have set up a postgres DB that is populated from two separate APIs. Maintaining our own database allows us to eliminate the data overlap from the APIs having similar but different models. When we pull from the APIs we parse the data on the back-end. We have scripts to format and group the data into our DB models. Once "trimmed" we load the data into our DB with JSON. Our DB models are structured so that the front end can access all of the DB information in a simple, complete, and interconnected format. Our front-end users experience easy access to the DB so they can cross-reference their own encyclopedic knowledge. There are pages that display information by book, house, and characters. Users may also intuitively sort the information by attribute (Asc, Desc). There is also a search bar in the upper right corner of each page to quickly look up information by attribute value. As our DB grows to include more models we will build pages to match; Currently each model instance has its own page. Each instance has more than one link to other instances, of one model or another, which means that each front end page has links to related pages. End users can traverse the pages in a mapped pattern due to the intricate connection between the pages on foreign keys. Users will find this experience very similar to websites like IMDB.</p>
	<!--> 313<-->
	<h2>RESTful API</h2>
	<p>Two APIs are scraped to populate our DB models. An API of Ice and Fire, and GOT API, these APIs have detailed information on each character, house, book, and location. This allows for the basic models for Character, House, and Book. The attributes of these models are slightly different across these two APIs. This causes an issue when merging the datasets. Our application runs back end scripts that "trims" and formats the dataset. The attributes of these basic models allows for the formation of more complex models, like alliances or events. The complex models use foreign keys represent relationships such as fealty (of a character or a house). The GOT API has more models than the API of Ice and Fire; such as, models for events, continents, cultures, etc. These models are not directly used by our application but can be easily utilized in future iterations. We plan to expand our DB using these models to create models for major events like wars which travers many characters, houses, regions, books, etc. These, and future, models could be linked to DB models in any number of interesting ways.</p>
	<!--> 187<-->
	<h2>Models</h2>

	<h3>Book Model:</h3>
	<p>The Book model contains the following attributes: ID, number of pages, ISBN number, title, publisher, country of origin, list of pov characters, author, media type, release date, list of all characters.</p>
	<p>The Book model represents one of the many literary installments in the "A Song of Fire and Ice" storyline. This model allows our website to give the end user all pertinent data regarding any given book. The functionality of our books model can be extended by adding foreign keys for new and complex models. Each book covers a massive amount of characters, places, and events that can be linked to the book using our other models. Currently the basic behavior of linking this model to all of the characters that appear in the book allows our end users to examine each character in detail. We can even differentiate main characters from supporting roles due to the separation of POV and all character sets. Each row in the books table shares several attributes including author and media type, however the unique constraints on ID, name, and ISBN allow us to link complex models back to the book model and sort in a number of ways.</p>
    
    <h3>Character Model:</h3>
    <p>The Character model contains the following attributes: ID, house, culture, title(s), spouse, died, aliases, date of death, name, born, gender, father, allegiances, pov books, played by, books, tv series, mother, male</p>
    <p>The Character model describes a person, animal, or creature that appeared in any book or media relating to the series "A Game of Thrones." Each distinct character is an instance of this model with some required, and some optional, attribues. However, there are some redundant attributes due to the combination of two separate APIs.  This explains the presence of both male and gender attributes in the same model. Even so, this model allows us to search for characters by blood line, allegiance, books appeared in, or actor. Furthermore it links to the Books, Houses, and Alliances models so that users can switch back and forth between examining specific character data and more general groups of data. Characters are members of each of the other models because it is the simplest of our models. While many models contain lists of characters, the character model itself links to only one house and/or alliance. Each character is linked in some way to the rest of the DB because by definition they must be a member of a house and have appeared in one or more books. Additionally, we can create complex models to model the relationship between characters like a family or employer model. the Character model can be easily extended to add foreign keys to link to models like major events or covert plots. The Character model is the central model that links books, houses, and alliances together.</p>

    <h3>House Model:</h3>
    <p> The House model contains the following attributes: ID, current lord, founder, heir, cadet branches, founded, died out, titles, coat of arms, words, seats, overlord, name, sworn members, region, and ancestral weapons. </p>
    <p>The House model groups characters together based on the family they belong to or lord they owe allegiance to. However, houses are much more than a simple collection of characters. Each house has many defining characteristics that uniquely identify them within the fantasy world of "A Song of Ice and Fire". Characteristics like family motto ("words"), strategic points they control ("seats"), and ownership of weapons ("ancestral weapons"). Many characters can be sworn to a house, and an entire house can be sworn to another house (i.e. Karstark -> Stark). This allows us to create complex models like an Alliance Model that groups houses/characters into trees of allegiance. In addition, we can expand the relationships between houses such as rivalries, wars, and debts. Models of these events would use the house's ID as foreign key to associate them with a particular house in our database. This would allow users to visualize the complex relationships between the houses in "A Game of Thrones". Houses also have attributes for coat of arms and words which are displayed on each houses page as static media. This functionality can be extended to include media linked to castles("seats") or ancestral weapons. </p>

    <h3>Alliance Model:</h3>
    <p> The Alliance model contains the following attributes: ID, head leader, members, weapons, seats, regions, and cultures. </p>
    <p>The Aliances Module creates groups of houses based on the tree structure of the allegiance attribute. The leader of the root house of the allegiance tree is the head leader of the alliance. For example Stark would be the leader of the North Alliance. Every house in the alliance contributes its members, weapons, seats, regions, and cultures to the overall alliance. This model allows users to actually quantify the strengths of each alliance. We can extend this model to display the regions an alliance controls or ancestral weapons. This model could be further extended to include significant historical events (i.e. wars) that the alliance participated in and even which characters from the alliance died.</p>
    <p>This is a completely original model that does not appear in either of the APIs but joins data from both. This model and others that can be created from the existing data sets are what compose the majority of our site's functionality. Just like we did to create the Alliance Module; we can create complex models that link the basic Character, House, and Book models. This will allow the end user to see more interesting data sets than just a list of every single character, book, or house.</p>

    <img src="static/img/yuml.png" alt="UML" style="display:block;margin:0 auto;">

	<h2>Tools</h2>
	<h3>Front-End Tools</h3>
	<p>Our front-end is run on flask templates that build static HTML pages. We have a base html page that includes the navigation bar and headers that all other pages extend. This way we can expand our front-end dynamically and always maintain consistency across pages. We also include a context function that highlights the navigation entry corresponding with the currently active page. This tiny detail nonetheless adds style and sophistication to the UI. Each model instance has its own static page that lists all of its pertinent data from the APIs. Flask is especially useful because we can easily add templates to instruct it to build pages based on new models. This allows our website to scale because every time we build a new model flask is able to create pages for each instance of that model based off of the template we define. These templates can be defined so that they display the correct subset of information from our models as well as any linked image files in the API.</p>
	<p>Although we did not use it in this phase of the project, we plan to make heavy use of React.js in the future. Our application currently only serves up static pages, in both the detail view and the listing view for each model type. In the future, when we implement sorting and filtering, we need to make the page dynamic with React. This will allow us to hit our API for filtering/sorting and update the page in realtime, without any messy background AJAX requests. </p>
	
	<h3>Back-End Tools</h3>
	<p>Our application uses the standard requests and JSON library to query the APIs we use to populate our models and images. After we have received the JSON data dumps we use trim scripts to format the data into the desired input format. Firstly, we determine which entity we are dealing with which defines which attributes are required. Then we break the data into its required fields which allows us to populate our models fully while throwing out unneeded data. The complexity comes in when you take into account the differences between the two API data sets. For example in GOT API a name may be listed as Eddard Stark while on the API of Ice and FIre the name would be listed as Eddard Stark, Lord of Winterfel. In order to resolve this issue we search for names as sub strings so Eddard Stark would be returned because it is a sub string of both listed names. Unfortunately this creates a source of error that can only be controlled by creating a very specific script/method to handle each data set. We did so, creating a script called trimdata.py which does all of the back-end formatting work before saving cached data to disk. Our site is then able to use this data without making constant calls to the API and having to trim each new dataset. </p>
	
	<h3>Embedding-Media Tools:</h3>
	<p>We have embedded a carousel of images on the home page, populated from prestored images. In addition, houses, characters, books and alliances all have embeddable media on their detail pages. Characters and houses both get their embedded media from the resources hosted on api.got.show, and the books get their embedded media from the cover-art associated with them. The embedded media for each alliance is simply built out of the largest 4 houses' crests that make up that alliance. </p>
	
	<h2>Hosting</h2>
	<p>For hosting we decided to use Amazon Web Service(AWS). We decided AWS’s Elastic Beanstalk was the perfect hosting platform for our project because it supported the flask framework. We used the flask framework to structure our front-end and make sure it was scallable to any number of instances. Elastic Beanstalk (EB for short) does not support everything and that’s why it is key that it supports flask.  Elastic beanstalk not only acts as a host environment, but it adds some nice extra functionality on top of it, such as giving itself a URL right off the start. The next reason we chose to use it is that the applications deployment process across machines can easily be replicated due to the AWS elastic beanstalk cli. Beanstalk also reduces the management complexity for our application by handling capacity provisioning, load balancing, scaling. It also offers application health monitoring.  Beanstalk also has a nice versioning system so that we can easily roll back our application upon failed deployment, or because of deploying bad code. </p>
	<p>The step by step setup of the project goes as follows. (Prerequisite: you must have Python3.4, pip, virtualenv, and the awsebcli installed to perform the next steps. You must also have the idb repo locally)</p>
	<h4>Create a virtualenv</h4>
	<p style="margin-left: 40px">    virtualenv ~/eb-virt</p>
	<h4>Activate virtualenv</h4>
	<p style="margin-left: 40px">    source ~/eb-virt/bin/activate</p>
	<h4>Navigate to IDB and install requirment</h4>
	<p style="margin-left: 40px">    pip install -r idb/requirment.txt</p>
	<h4>Initialize eb clie repo</h4>
	<p style="margin-left: 40px">    eb init -p python2.7 flask tutorial</p>
	<h4>Create an eb environment to deploy application into</h4>
	<p style="margin-left: 40px">    eb create flask-env</p>
	<p>To make deployment to beanstalk even simpler and to make development more streamlined, we used Pycharm’s built in Elastic Beanstalk plugin to handle deployment as a run configuration. This plugin syncs with your AWS account. Allows you to select and environment to deploy to and streamlines deployment whenever the user is ready to deploy by selecting the Elastic Beanstalk run configuration. </p>
</div>
{% endblock %}

<!--Write an initial technical report
It must be at least 2500 words.
The report must be embedded in the website.
Document the use cases, RESTful API, models, tools, and hosting well.
The audience comprises other software developers, as opposed to users.
Format the report clearly, attractively, and consistently, using good sections, multiple pages, good headers, figures, and grammar. -->
